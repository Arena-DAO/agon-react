/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { Uint64, InstantiateMsg, AddMemberMsg, ExecuteMsg, Action, Expiration, Timestamp, MemberMsgForString, QueryMsg, MigrateMsg, Boolean, MemberListResponse, Member, MemberResponse, Addr, ArrayOfMemberMsgForAddr, MemberMsgForAddr, OwnershipForString, TotalWeightResponse } from "./ArenaGroup.types";
import { ArenaGroupQueryClient, ArenaGroupClient } from "./ArenaGroup.client";
export const arenaGroupQueryKeys = {
  contract: ([{
    contract: "arenaGroup"
  }] as const),
  address: (contractAddress: string | undefined) => ([{
    ...arenaGroupQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  members: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaGroupQueryKeys.address(contractAddress)[0],
    method: "members",
    args
  }] as const),
  membersCount: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaGroupQueryKeys.address(contractAddress)[0],
    method: "members_count",
    args
  }] as const),
  isValidDistribution: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaGroupQueryKeys.address(contractAddress)[0],
    method: "is_valid_distribution",
    args
  }] as const),
  isMember: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaGroupQueryKeys.address(contractAddress)[0],
    method: "is_member",
    args
  }] as const),
  totalWeight: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaGroupQueryKeys.address(contractAddress)[0],
    method: "total_weight",
    args
  }] as const),
  listMembers: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaGroupQueryKeys.address(contractAddress)[0],
    method: "list_members",
    args
  }] as const),
  member: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaGroupQueryKeys.address(contractAddress)[0],
    method: "member",
    args
  }] as const),
  ownership: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{
    ...arenaGroupQueryKeys.address(contractAddress)[0],
    method: "ownership",
    args
  }] as const)
};
export const arenaGroupQueries = {
  members: <TData = ArrayOfMemberMsgForAddr,>({
    client,
    args,
    options
  }: ArenaGroupMembersQuery<TData>): UseQueryOptions<ArrayOfMemberMsgForAddr, Error, TData> => ({
    queryKey: arenaGroupQueryKeys.members(client?.contractAddress, args),
    queryFn: () => client ? client.members({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  membersCount: <TData = Uint64,>({
    client,
    options
  }: ArenaGroupMembersCountQuery<TData>): UseQueryOptions<Uint64, Error, TData> => ({
    queryKey: arenaGroupQueryKeys.membersCount(client?.contractAddress),
    queryFn: () => client ? client.membersCount() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  isValidDistribution: <TData = Boolean,>({
    client,
    args,
    options
  }: ArenaGroupIsValidDistributionQuery<TData>): UseQueryOptions<Boolean, Error, TData> => ({
    queryKey: arenaGroupQueryKeys.isValidDistribution(client?.contractAddress, args),
    queryFn: () => client ? client.isValidDistribution({
      addrs: args.addrs
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  isMember: <TData = Boolean,>({
    client,
    args,
    options
  }: ArenaGroupIsMemberQuery<TData>): UseQueryOptions<Boolean, Error, TData> => ({
    queryKey: arenaGroupQueryKeys.isMember(client?.contractAddress, args),
    queryFn: () => client ? client.isMember({
      addr: args.addr
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  totalWeight: <TData = TotalWeightResponse,>({
    client,
    args,
    options
  }: ArenaGroupTotalWeightQuery<TData>): UseQueryOptions<TotalWeightResponse, Error, TData> => ({
    queryKey: arenaGroupQueryKeys.totalWeight(client?.contractAddress, args),
    queryFn: () => client ? client.totalWeight({
      atHeight: args.atHeight
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  listMembers: <TData = MemberListResponse,>({
    client,
    args,
    options
  }: ArenaGroupListMembersQuery<TData>): UseQueryOptions<MemberListResponse, Error, TData> => ({
    queryKey: arenaGroupQueryKeys.listMembers(client?.contractAddress, args),
    queryFn: () => client ? client.listMembers({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  member: <TData = MemberResponse,>({
    client,
    args,
    options
  }: ArenaGroupMemberQuery<TData>): UseQueryOptions<MemberResponse, Error, TData> => ({
    queryKey: arenaGroupQueryKeys.member(client?.contractAddress, args),
    queryFn: () => client ? client.member({
      addr: args.addr,
      atHeight: args.atHeight
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  ownership: <TData = OwnershipForString,>({
    client,
    options
  }: ArenaGroupOwnershipQuery<TData>): UseQueryOptions<OwnershipForString, Error, TData> => ({
    queryKey: arenaGroupQueryKeys.ownership(client?.contractAddress),
    queryFn: () => client ? client.ownership() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface ArenaGroupReactQuery<TResponse, TData = TResponse> {
  client: ArenaGroupQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface ArenaGroupOwnershipQuery<TData> extends ArenaGroupReactQuery<OwnershipForString, TData> {}
export function useArenaGroupOwnershipQuery<TData = OwnershipForString>({
  client,
  options
}: ArenaGroupOwnershipQuery<TData>) {
  return useQuery<OwnershipForString, Error, TData>(arenaGroupQueryKeys.ownership(client?.contractAddress), () => client ? client.ownership() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaGroupMemberQuery<TData> extends ArenaGroupReactQuery<MemberResponse, TData> {
  args: {
    addr: string;
    atHeight?: number;
  };
}
export function useArenaGroupMemberQuery<TData = MemberResponse>({
  client,
  args,
  options
}: ArenaGroupMemberQuery<TData>) {
  return useQuery<MemberResponse, Error, TData>(arenaGroupQueryKeys.member(client?.contractAddress, args), () => client ? client.member({
    addr: args.addr,
    atHeight: args.atHeight
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaGroupListMembersQuery<TData> extends ArenaGroupReactQuery<MemberListResponse, TData> {
  args: {
    limit?: number;
    startAfter?: string;
  };
}
export function useArenaGroupListMembersQuery<TData = MemberListResponse>({
  client,
  args,
  options
}: ArenaGroupListMembersQuery<TData>) {
  return useQuery<MemberListResponse, Error, TData>(arenaGroupQueryKeys.listMembers(client?.contractAddress, args), () => client ? client.listMembers({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaGroupTotalWeightQuery<TData> extends ArenaGroupReactQuery<TotalWeightResponse, TData> {
  args: {
    atHeight?: number;
  };
}
export function useArenaGroupTotalWeightQuery<TData = TotalWeightResponse>({
  client,
  args,
  options
}: ArenaGroupTotalWeightQuery<TData>) {
  return useQuery<TotalWeightResponse, Error, TData>(arenaGroupQueryKeys.totalWeight(client?.contractAddress, args), () => client ? client.totalWeight({
    atHeight: args.atHeight
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaGroupIsMemberQuery<TData> extends ArenaGroupReactQuery<Boolean, TData> {
  args: {
    addr: string;
  };
}
export function useArenaGroupIsMemberQuery<TData = Boolean>({
  client,
  args,
  options
}: ArenaGroupIsMemberQuery<TData>) {
  return useQuery<Boolean, Error, TData>(arenaGroupQueryKeys.isMember(client?.contractAddress, args), () => client ? client.isMember({
    addr: args.addr
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaGroupIsValidDistributionQuery<TData> extends ArenaGroupReactQuery<Boolean, TData> {
  args: {
    addrs: string[];
  };
}
export function useArenaGroupIsValidDistributionQuery<TData = Boolean>({
  client,
  args,
  options
}: ArenaGroupIsValidDistributionQuery<TData>) {
  return useQuery<Boolean, Error, TData>(arenaGroupQueryKeys.isValidDistribution(client?.contractAddress, args), () => client ? client.isValidDistribution({
    addrs: args.addrs
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaGroupMembersCountQuery<TData> extends ArenaGroupReactQuery<Uint64, TData> {}
export function useArenaGroupMembersCountQuery<TData = Uint64>({
  client,
  options
}: ArenaGroupMembersCountQuery<TData>) {
  return useQuery<Uint64, Error, TData>(arenaGroupQueryKeys.membersCount(client?.contractAddress), () => client ? client.membersCount() : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaGroupMembersQuery<TData> extends ArenaGroupReactQuery<ArrayOfMemberMsgForAddr, TData> {
  args: {
    limit?: number;
    startAfter?: MemberMsgForString;
  };
}
export function useArenaGroupMembersQuery<TData = ArrayOfMemberMsgForAddr>({
  client,
  args,
  options
}: ArenaGroupMembersQuery<TData>) {
  return useQuery<ArrayOfMemberMsgForAddr, Error, TData>(arenaGroupQueryKeys.members(client?.contractAddress, args), () => client ? client.members({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), {
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface ArenaGroupUpdateOwnershipMutation {
  client: ArenaGroupClient;
  msg: Action;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaGroupUpdateOwnershipMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaGroupUpdateOwnershipMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaGroupUpdateOwnershipMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateOwnership(msg, fee, memo, funds), options);
}
export interface ArenaGroupUpdateMembersMutation {
  client: ArenaGroupClient;
  msg: {
    toAdd?: AddMemberMsg[];
    toRemove?: string[];
    toUpdate?: MemberMsgForString[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useArenaGroupUpdateMembersMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, ArenaGroupUpdateMembersMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, ArenaGroupUpdateMembersMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateMembers(msg, fee, memo, funds), options);
}