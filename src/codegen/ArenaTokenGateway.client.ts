/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Decimal, InstantiateMsg, VestingConfiguration, ExecuteMsg, Uint128, Action, Expiration, Timestamp, Uint64, ApplyMsg, ProjectLink, QueryMsg, ApplicationsFilter, ApplicationStatus, MigrateMsg, Addr, ApplicationResponse, ApplicationInfo, ArrayOfApplicationResponse, OwnershipForString } from "./ArenaTokenGateway.types";
export interface ArenaTokenGatewayReadOnlyInterface {
  contractAddress: string;
  vestingConfiguration: () => Promise<VestingConfiguration>;
  application: ({
    applicationId
  }: {
    applicationId: Uint128;
  }) => Promise<ApplicationResponse>;
  applications: ({
    filter,
    limit,
    startAfter
  }: {
    filter?: ApplicationsFilter;
    limit?: number;
    startAfter?: Uint128;
  }) => Promise<ArrayOfApplicationResponse>;
  payrollAddress: () => Promise<Addr>;
  ownership: () => Promise<OwnershipForString>;
}
export class ArenaTokenGatewayQueryClient implements ArenaTokenGatewayReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.vestingConfiguration = this.vestingConfiguration.bind(this);
    this.application = this.application.bind(this);
    this.applications = this.applications.bind(this);
    this.payrollAddress = this.payrollAddress.bind(this);
    this.ownership = this.ownership.bind(this);
  }
  vestingConfiguration = async (): Promise<VestingConfiguration> => {
    return this.client.queryContractSmart(this.contractAddress, {
      vesting_configuration: {}
    });
  };
  application = async ({
    applicationId
  }: {
    applicationId: Uint128;
  }): Promise<ApplicationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      application: {
        application_id: applicationId
      }
    });
  };
  applications = async ({
    filter,
    limit,
    startAfter
  }: {
    filter?: ApplicationsFilter;
    limit?: number;
    startAfter?: Uint128;
  }): Promise<ArrayOfApplicationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      applications: {
        filter,
        limit,
        start_after: startAfter
      }
    });
  };
  payrollAddress = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      payroll_address: {}
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {}
    });
  };
}
export interface ArenaTokenGatewayInterface extends ArenaTokenGatewayReadOnlyInterface {
  contractAddress: string;
  sender: string;
  apply: ({
    description,
    projectLinks,
    requestedAmount,
    title
  }: {
    description: string;
    projectLinks: ProjectLink[];
    requestedAmount: Uint128;
    title: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  update: ({
    applicationId,
    applicationInfo
  }: {
    applicationId: Uint128;
    applicationInfo: ApplyMsg;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    applicationId
  }: {
    applicationId: Uint128;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  acceptApplication: ({
    applicationId
  }: {
    applicationId: Uint128;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  rejectApplication: ({
    applicationId,
    reason
  }: {
    applicationId: Uint128;
    reason?: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateVestingConfiguration: ({
    config
  }: {
    config: VestingConfiguration;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateOwnership: (action: Action, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class ArenaTokenGatewayClient extends ArenaTokenGatewayQueryClient implements ArenaTokenGatewayInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.apply = this.apply.bind(this);
    this.update = this.update.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.acceptApplication = this.acceptApplication.bind(this);
    this.rejectApplication = this.rejectApplication.bind(this);
    this.updateVestingConfiguration = this.updateVestingConfiguration.bind(this);
    this.updateOwnership = this.updateOwnership.bind(this);
  }
  apply = async ({
    description,
    projectLinks,
    requestedAmount,
    title
  }: {
    description: string;
    projectLinks: ProjectLink[];
    requestedAmount: Uint128;
    title: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      apply: {
        description,
        project_links: projectLinks,
        requested_amount: requestedAmount,
        title
      }
    }, fee_, memo_, funds_);
  };
  update = async ({
    applicationId,
    applicationInfo
  }: {
    applicationId: Uint128;
    applicationInfo: ApplyMsg;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update: {
        application_id: applicationId,
        application_info: applicationInfo
      }
    }, fee_, memo_, funds_);
  };
  withdraw = async ({
    applicationId
  }: {
    applicationId: Uint128;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        application_id: applicationId
      }
    }, fee_, memo_, funds_);
  };
  acceptApplication = async ({
    applicationId
  }: {
    applicationId: Uint128;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_application: {
        application_id: applicationId
      }
    }, fee_, memo_, funds_);
  };
  rejectApplication = async ({
    applicationId,
    reason
  }: {
    applicationId: Uint128;
    reason?: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reject_application: {
        application_id: applicationId,
        reason
      }
    }, fee_, memo_, funds_);
  };
  updateVestingConfiguration = async ({
    config
  }: {
    config: VestingConfiguration;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_vesting_configuration: {
        config
      }
    }, fee_, memo_, funds_);
  };
  updateOwnership = async (action: Action, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_ownership: action
    }, fee_, memo_, funds_);
  };
}