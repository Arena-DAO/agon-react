/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Decimal, InstantiateMsg, VestingConfiguration, ExecuteMsg, Uint128, Action, Expiration, Timestamp, Uint64, ApplyMsg, ProjectLink, QueryMsg, ApplicationsFilter, ApplicationStatus, MigrateMsg, Addr, ApplicationResponse, ApplicationInfo, ArrayOfApplicationResponse, OwnershipForString } from "./ArenaTokenGateway.types";
export interface ArenaTokenGatewayReadOnlyInterface {
  contractAddress: string;
  vestingConfiguration: () => Promise<VestingConfiguration>;
  application: ({
    applicationId
  }: {
    applicationId: Uint128;
  }) => Promise<ApplicationResponse>;
  applications: ({
    filter,
    limit,
    startAfter
  }: {
    filter?: ApplicationsFilter;
    limit?: number;
    startAfter?: Uint128;
  }) => Promise<ArrayOfApplicationResponse>;
  payrollAddress: () => Promise<Addr>;
  ownership: () => Promise<OwnershipForString>;
}
export class ArenaTokenGatewayQueryClient implements ArenaTokenGatewayReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.vestingConfiguration = this.vestingConfiguration.bind(this);
    this.application = this.application.bind(this);
    this.applications = this.applications.bind(this);
    this.payrollAddress = this.payrollAddress.bind(this);
    this.ownership = this.ownership.bind(this);
  }
  vestingConfiguration = async (): Promise<VestingConfiguration> => {
    return this.client.queryContractSmart(this.contractAddress, {
      vesting_configuration: {}
    });
  };
  application = async ({
    applicationId
  }: {
    applicationId: Uint128;
  }): Promise<ApplicationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      application: {
        application_id: applicationId
      }
    });
  };
  applications = async ({
    filter,
    limit,
    startAfter
  }: {
    filter?: ApplicationsFilter;
    limit?: number;
    startAfter?: Uint128;
  }): Promise<ArrayOfApplicationResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      applications: {
        filter,
        limit,
        start_after: startAfter
      }
    });
  };
  payrollAddress = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      payroll_address: {}
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {}
    });
  };
}
export interface ArenaTokenGatewayInterface extends ArenaTokenGatewayReadOnlyInterface {
  contractAddress: string;
  sender: string;
  apply: ({
    description,
    project_links,
    requested_amount,
    title
  }: {
    description: string;
    project_links: ProjectLink[];
    requested_amount: Uint128;
    title: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  update: ({
    applicationId,
    applicationInfo
  }: {
    applicationId: Uint128;
    applicationInfo: ApplyMsg;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    applicationId
  }: {
    applicationId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  acceptApplication: ({
    applicationId
  }: {
    applicationId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  rejectApplication: ({
    applicationId,
    reason
  }: {
    applicationId: Uint128;
    reason?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateVestingConfiguration: ({
    config
  }: {
    config: VestingConfiguration;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateOwnership: (action: Action, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ArenaTokenGatewayClient extends ArenaTokenGatewayQueryClient implements ArenaTokenGatewayInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.apply = this.apply.bind(this);
    this.update = this.update.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.acceptApplication = this.acceptApplication.bind(this);
    this.rejectApplication = this.rejectApplication.bind(this);
    this.updateVestingConfiguration = this.updateVestingConfiguration.bind(this);
    this.updateOwnership = this.updateOwnership.bind(this);
  }
  apply = async ({
    description,
    project_links,
    requested_amount,
    title
  }: {
    description: string;
    project_links: ProjectLink[];
    requested_amount: Uint128;
    title: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      apply: {
        description,
        project_links,
        requested_amount,
        title
      }
    }, fee, memo, _funds);
  };
  update = async ({
    applicationId,
    applicationInfo
  }: {
    applicationId: Uint128;
    applicationInfo: ApplyMsg;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update: {
        application_id: applicationId,
        application_info: applicationInfo
      }
    }, fee, memo, _funds);
  };
  withdraw = async ({
    applicationId
  }: {
    applicationId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        application_id: applicationId
      }
    }, fee, memo, _funds);
  };
  acceptApplication = async ({
    applicationId
  }: {
    applicationId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_application: {
        application_id: applicationId
      }
    }, fee, memo, _funds);
  };
  rejectApplication = async ({
    applicationId,
    reason
  }: {
    applicationId: Uint128;
    reason?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      reject_application: {
        application_id: applicationId,
        reason
      }
    }, fee, memo, _funds);
  };
  updateVestingConfiguration = async ({
    config
  }: {
    config: VestingConfiguration;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_vesting_configuration: {
        config
      }
    }, fee, memo, _funds);
  };
  updateOwnership = async (action: Action, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_ownership: action
    }, fee, memo, _funds);
  };
}