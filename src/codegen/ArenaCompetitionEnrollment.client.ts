/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.12.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Uint128, Binary, Decimal, Expiration, Timestamp, Uint64, CompetitionType, EliminationType, Admin, Action, CompetitionInfoMsg, FeeInformationForString, Coin, ModuleInstantiateInfo, QueryMsg, EnrollmentFilter, MigrateMsg, Addr, SudoMsg, EnrollmentEntryResponse, CompetitionInfoResponse, ArrayOfEnrollmentEntryResponse, Boolean, OwnershipForString } from "./ArenaCompetitionEnrollment.types";
export interface ArenaCompetitionEnrollmentReadOnlyInterface {
  contractAddress: string;
  enrollments: ({
    filter,
    limit,
    startAfter
  }: {
    filter?: EnrollmentFilter;
    limit?: number;
    startAfter?: Uint128;
  }) => Promise<ArrayOfEnrollmentEntryResponse>;
  enrollment: ({
    enrollmentId
  }: {
    enrollmentId: Uint128;
  }) => Promise<EnrollmentEntryResponse>;
  enrollmentCount: () => Promise<Uint128>;
  isMember: ({
    addr,
    enrollmentId
  }: {
    addr: string;
    enrollmentId: Uint128;
  }) => Promise<Boolean>;
  ownership: () => Promise<OwnershipForString>;
}
export class ArenaCompetitionEnrollmentQueryClient implements ArenaCompetitionEnrollmentReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;
  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.enrollments = this.enrollments.bind(this);
    this.enrollment = this.enrollment.bind(this);
    this.enrollmentCount = this.enrollmentCount.bind(this);
    this.isMember = this.isMember.bind(this);
    this.ownership = this.ownership.bind(this);
  }
  enrollments = async ({
    filter,
    limit,
    startAfter
  }: {
    filter?: EnrollmentFilter;
    limit?: number;
    startAfter?: Uint128;
  }): Promise<ArrayOfEnrollmentEntryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      enrollments: {
        filter,
        limit,
        start_after: startAfter
      }
    });
  };
  enrollment = async ({
    enrollmentId
  }: {
    enrollmentId: Uint128;
  }): Promise<EnrollmentEntryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      enrollment: {
        enrollment_id: enrollmentId
      }
    });
  };
  enrollmentCount = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      enrollment_count: {}
    });
  };
  isMember = async ({
    addr,
    enrollmentId
  }: {
    addr: string;
    enrollmentId: Uint128;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_member: {
        addr,
        enrollment_id: enrollmentId
      }
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {}
    });
  };
}
export interface ArenaCompetitionEnrollmentInterface extends ArenaCompetitionEnrollmentReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createEnrollment: ({
    categoryId,
    competitionInfo,
    competitionType,
    entryFee,
    expiration,
    groupContractInfo,
    maxMembers,
    minMembers,
    requireTeamSize
  }: {
    categoryId?: Uint128;
    competitionInfo: CompetitionInfoMsg;
    competitionType: CompetitionType;
    entryFee?: Coin;
    expiration: Expiration;
    groupContractInfo: ModuleInstantiateInfo;
    maxMembers: Uint64;
    minMembers?: Uint64;
    requireTeamSize?: number;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  triggerExpiration: ({
    escrowId,
    id
  }: {
    escrowId: number;
    id: Uint128;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  enroll: ({
    id,
    team
  }: {
    id: Uint128;
    team?: string;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    id
  }: {
    id: Uint128;
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  forceWithdraw: ({
    id,
    members
  }: {
    id: Uint128;
    members: string[];
  }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
  updateOwnership: (action: Action, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export class ArenaCompetitionEnrollmentClient extends ArenaCompetitionEnrollmentQueryClient implements ArenaCompetitionEnrollmentInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;
  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createEnrollment = this.createEnrollment.bind(this);
    this.triggerExpiration = this.triggerExpiration.bind(this);
    this.enroll = this.enroll.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.forceWithdraw = this.forceWithdraw.bind(this);
    this.updateOwnership = this.updateOwnership.bind(this);
  }
  createEnrollment = async ({
    categoryId,
    competitionInfo,
    competitionType,
    entryFee,
    expiration,
    groupContractInfo,
    maxMembers,
    minMembers,
    requireTeamSize
  }: {
    categoryId?: Uint128;
    competitionInfo: CompetitionInfoMsg;
    competitionType: CompetitionType;
    entryFee?: Coin;
    expiration: Expiration;
    groupContractInfo: ModuleInstantiateInfo;
    maxMembers: Uint64;
    minMembers?: Uint64;
    requireTeamSize?: number;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_enrollment: {
        category_id: categoryId,
        competition_info: competitionInfo,
        competition_type: competitionType,
        entry_fee: entryFee,
        expiration,
        group_contract_info: groupContractInfo,
        max_members: maxMembers,
        min_members: minMembers,
        require_team_size: requireTeamSize
      }
    }, fee_, memo_, funds_);
  };
  triggerExpiration = async ({
    escrowId,
    id
  }: {
    escrowId: number;
    id: Uint128;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      trigger_expiration: {
        escrow_id: escrowId,
        id
      }
    }, fee_, memo_, funds_);
  };
  enroll = async ({
    id,
    team
  }: {
    id: Uint128;
    team?: string;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      enroll: {
        id,
        team
      }
    }, fee_, memo_, funds_);
  };
  withdraw = async ({
    id
  }: {
    id: Uint128;
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        id
      }
    }, fee_, memo_, funds_);
  };
  forceWithdraw = async ({
    id,
    members
  }: {
    id: Uint128;
    members: string[];
  }, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      force_withdraw: {
        id,
        members
      }
    }, fee_, memo_, funds_);
  };
  updateOwnership = async (action: Action, fee_: number | StdFee | "auto" = "auto", memo_?: string, funds_?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_ownership: action
    }, fee_, memo_, funds_);
  };
}