/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Uint128, Binary, Decimal, Expiration, Timestamp, Uint64, CompetitionType, EliminationType, Action, CompetitionInfoMsg, FeeInformationForString, Coin, QueryMsg, EnrollmentFilter, MigrateMsg, Addr, SudoMsg, EnrollmentEntryResponse, CompetitionInfoResponse, ArrayOfEnrollmentEntryResponse, OwnershipForString } from "./ArenaCompetitionEnrollment.types";
export interface ArenaCompetitionEnrollmentReadOnlyInterface {
  contractAddress: string;
  enrollments: ({
    filter,
    limit,
    startAfter
  }: {
    filter?: EnrollmentFilter;
    limit?: number;
    startAfter?: Uint128;
  }) => Promise<ArrayOfEnrollmentEntryResponse>;
  enrollment: ({
    id
  }: {
    id: Uint128;
  }) => Promise<EnrollmentEntryResponse>;
  enrollmentCount: () => Promise<Uint128>;
  ownership: () => Promise<OwnershipForString>;
}
export class ArenaCompetitionEnrollmentQueryClient implements ArenaCompetitionEnrollmentReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.enrollments = this.enrollments.bind(this);
    this.enrollment = this.enrollment.bind(this);
    this.enrollmentCount = this.enrollmentCount.bind(this);
    this.ownership = this.ownership.bind(this);
  }

  enrollments = async ({
    filter,
    limit,
    startAfter
  }: {
    filter?: EnrollmentFilter;
    limit?: number;
    startAfter?: Uint128;
  }): Promise<ArrayOfEnrollmentEntryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      enrollments: {
        filter,
        limit,
        start_after: startAfter
      }
    });
  };
  enrollment = async ({
    id
  }: {
    id: Uint128;
  }): Promise<EnrollmentEntryResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      enrollment: {
        id
      }
    });
  };
  enrollmentCount = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      enrollment_count: {}
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {}
    });
  };
}
export interface ArenaCompetitionEnrollmentInterface extends ArenaCompetitionEnrollmentReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createEnrollment: ({
    categoryId,
    competitionInfo,
    competitionType,
    entryFee,
    expiration,
    isCreatorMember,
    maxMembers,
    minMembers
  }: {
    categoryId?: Uint128;
    competitionInfo: CompetitionInfoMsg;
    competitionType: CompetitionType;
    entryFee?: Coin;
    expiration: Expiration;
    isCreatorMember?: boolean;
    maxMembers: Uint64;
    minMembers?: Uint64;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  triggerExpiration: ({
    escrowId,
    id
  }: {
    escrowId: number;
    id: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  enroll: ({
    id
  }: {
    id: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: ({
    id
  }: {
    id: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateOwnership: (action: Action, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class ArenaCompetitionEnrollmentClient extends ArenaCompetitionEnrollmentQueryClient implements ArenaCompetitionEnrollmentInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createEnrollment = this.createEnrollment.bind(this);
    this.triggerExpiration = this.triggerExpiration.bind(this);
    this.enroll = this.enroll.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.updateOwnership = this.updateOwnership.bind(this);
  }

  createEnrollment = async ({
    categoryId,
    competitionInfo,
    competitionType,
    entryFee,
    expiration,
    isCreatorMember,
    maxMembers,
    minMembers
  }: {
    categoryId?: Uint128;
    competitionInfo: CompetitionInfoMsg;
    competitionType: CompetitionType;
    entryFee?: Coin;
    expiration: Expiration;
    isCreatorMember?: boolean;
    maxMembers: Uint64;
    minMembers?: Uint64;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_enrollment: {
        category_id: categoryId,
        competition_info: competitionInfo,
        competition_type: competitionType,
        entry_fee: entryFee,
        expiration,
        is_creator_member: isCreatorMember,
        max_members: maxMembers,
        min_members: minMembers
      }
    }, fee, memo, _funds);
  };
  triggerExpiration = async ({
    escrowId,
    id
  }: {
    escrowId: number;
    id: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      trigger_expiration: {
        escrow_id: escrowId,
        id
      }
    }, fee, memo, _funds);
  };
  enroll = async ({
    id
  }: {
    id: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      enroll: {
        id
      }
    }, fee, memo, _funds);
  };
  withdraw = async ({
    id
  }: {
    id: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {
        id
      }
    }, fee, memo, _funds);
  };
  updateOwnership = async (action: Action, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_ownership: action
    }, fee, memo, _funds);
  };
}