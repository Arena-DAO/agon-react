/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.34.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { UncheckedDenom, Schedule, Uint128, Timestamp, Uint64, InstantiateMsg, ExecuteMsg, Binary, Action, Expiration, Cw20ReceiveMsg, QueryMsg, StakeTrackerQuery, CheckedDenom, Addr, Status, Curve, Vest, SaturatingLinear, PiecewiseLinear, OwnershipForAddr, NullableUint64 } from "./CwVesting.types";
import { CwVestingQueryClient, CwVestingClient } from "./CwVesting.client";
export const cwVestingQueryKeys = {
  contract: ([{
    contract: "cwVesting"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...cwVestingQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  ownership: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwVestingQueryKeys.address(contractAddress)[0],
    method: "ownership",
    args
  }] as const),
  info: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwVestingQueryKeys.address(contractAddress)[0],
    method: "info",
    args
  }] as const),
  distributable: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwVestingQueryKeys.address(contractAddress)[0],
    method: "distributable",
    args
  }] as const),
  vested: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwVestingQueryKeys.address(contractAddress)[0],
    method: "vested",
    args
  }] as const),
  totalToVest: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwVestingQueryKeys.address(contractAddress)[0],
    method: "total_to_vest",
    args
  }] as const),
  vestDuration: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwVestingQueryKeys.address(contractAddress)[0],
    method: "vest_duration",
    args
  }] as const),
  stake: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...cwVestingQueryKeys.address(contractAddress)[0],
    method: "stake",
    args
  }] as const)
};
export const cwVestingQueries = {
  ownership: <TData = OwnershipForAddr,>({
    client,
    options
  }: CwVestingOwnershipQuery<TData>): UseQueryOptions<OwnershipForAddr, Error, TData> => ({
    queryKey: cwVestingQueryKeys.ownership(client?.contractAddress),
    queryFn: () => client ? client.ownership() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  info: <TData = Vest,>({
    client,
    options
  }: CwVestingInfoQuery<TData>): UseQueryOptions<Vest, Error, TData> => ({
    queryKey: cwVestingQueryKeys.info(client?.contractAddress),
    queryFn: () => client ? client.info() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  distributable: <TData = Uint128,>({
    client,
    args,
    options
  }: CwVestingDistributableQuery<TData>): UseQueryOptions<Uint128, Error, TData> => ({
    queryKey: cwVestingQueryKeys.distributable(client?.contractAddress, args),
    queryFn: () => client ? client.distributable({
      t: args.t
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  vested: <TData = Uint128,>({
    client,
    args,
    options
  }: CwVestingVestedQuery<TData>): UseQueryOptions<Uint128, Error, TData> => ({
    queryKey: cwVestingQueryKeys.vested(client?.contractAddress, args),
    queryFn: () => client ? client.vested({
      t: args.t
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  totalToVest: <TData = Uint128,>({
    client,
    options
  }: CwVestingTotalToVestQuery<TData>): UseQueryOptions<Uint128, Error, TData> => ({
    queryKey: cwVestingQueryKeys.totalToVest(client?.contractAddress),
    queryFn: () => client ? client.totalToVest() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  vestDuration: <TData = NullableUint64,>({
    client,
    options
  }: CwVestingVestDurationQuery<TData>): UseQueryOptions<NullableUint64, Error, TData> => ({
    queryKey: cwVestingQueryKeys.vestDuration(client?.contractAddress),
    queryFn: () => client ? client.vestDuration() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  stake: <TData = Uint128,>({
    client,
    options
  }: CwVestingStakeQuery<TData>): UseQueryOptions<Uint128, Error, TData> => ({
    queryKey: cwVestingQueryKeys.stake(client?.contractAddress),
    queryFn: () => client ? client.stake() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface CwVestingReactQuery<TResponse, TData = TResponse> {
  client: CwVestingQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface CwVestingStakeQuery<TData> extends CwVestingReactQuery<Uint128, TData> {}
export function useCwVestingStakeQuery<TData = Uint128>({
  client,
  options
}: CwVestingStakeQuery<TData>) {
  return useQuery<Uint128, Error, TData>(cwVestingQueryKeys.stake(client?.contractAddress), () => client ? client.stake() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwVestingVestDurationQuery<TData> extends CwVestingReactQuery<NullableUint64, TData> {}
export function useCwVestingVestDurationQuery<TData = NullableUint64>({
  client,
  options
}: CwVestingVestDurationQuery<TData>) {
  return useQuery<NullableUint64, Error, TData>(cwVestingQueryKeys.vestDuration(client?.contractAddress), () => client ? client.vestDuration() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwVestingTotalToVestQuery<TData> extends CwVestingReactQuery<Uint128, TData> {}
export function useCwVestingTotalToVestQuery<TData = Uint128>({
  client,
  options
}: CwVestingTotalToVestQuery<TData>) {
  return useQuery<Uint128, Error, TData>(cwVestingQueryKeys.totalToVest(client?.contractAddress), () => client ? client.totalToVest() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwVestingVestedQuery<TData> extends CwVestingReactQuery<Uint128, TData> {
  args: {
    t?: Timestamp;
  };
}
export function useCwVestingVestedQuery<TData = Uint128>({
  client,
  args,
  options
}: CwVestingVestedQuery<TData>) {
  return useQuery<Uint128, Error, TData>(cwVestingQueryKeys.vested(client?.contractAddress, args), () => client ? client.vested({
    t: args.t
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwVestingDistributableQuery<TData> extends CwVestingReactQuery<Uint128, TData> {
  args: {
    t?: Timestamp;
  };
}
export function useCwVestingDistributableQuery<TData = Uint128>({
  client,
  args,
  options
}: CwVestingDistributableQuery<TData>) {
  return useQuery<Uint128, Error, TData>(cwVestingQueryKeys.distributable(client?.contractAddress, args), () => client ? client.distributable({
    t: args.t
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwVestingInfoQuery<TData> extends CwVestingReactQuery<Vest, TData> {}
export function useCwVestingInfoQuery<TData = Vest>({
  client,
  options
}: CwVestingInfoQuery<TData>) {
  return useQuery<Vest, Error, TData>(cwVestingQueryKeys.info(client?.contractAddress), () => client ? client.info() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwVestingOwnershipQuery<TData> extends CwVestingReactQuery<OwnershipForAddr, TData> {}
export function useCwVestingOwnershipQuery<TData = OwnershipForAddr>({
  client,
  options
}: CwVestingOwnershipQuery<TData>) {
  return useQuery<OwnershipForAddr, Error, TData>(cwVestingQueryKeys.ownership(client?.contractAddress), () => client ? client.ownership() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface CwVestingUpdateOwnershipMutation {
  client: CwVestingClient;
  msg: Action;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingUpdateOwnershipMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingUpdateOwnershipMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingUpdateOwnershipMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateOwnership(msg, fee, memo, funds), options);
}
export interface CwVestingRegisterSlashMutation {
  client: CwVestingClient;
  msg: {
    amount: Uint128;
    duringUnbonding: boolean;
    time: Timestamp;
    validator: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingRegisterSlashMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingRegisterSlashMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingRegisterSlashMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.registerSlash(msg, fee, memo, funds), options);
}
export interface CwVestingWithdrawCanceledPaymentMutation {
  client: CwVestingClient;
  msg: {
    amount?: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingWithdrawCanceledPaymentMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingWithdrawCanceledPaymentMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingWithdrawCanceledPaymentMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdrawCanceledPayment(msg, fee, memo, funds), options);
}
export interface CwVestingWithdrawDelegatorRewardMutation {
  client: CwVestingClient;
  msg: {
    validator: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingWithdrawDelegatorRewardMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingWithdrawDelegatorRewardMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingWithdrawDelegatorRewardMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.withdrawDelegatorReward(msg, fee, memo, funds), options);
}
export interface CwVestingSetWithdrawAddressMutation {
  client: CwVestingClient;
  msg: {
    address: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingSetWithdrawAddressMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingSetWithdrawAddressMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingSetWithdrawAddressMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.setWithdrawAddress(msg, fee, memo, funds), options);
}
export interface CwVestingUndelegateMutation {
  client: CwVestingClient;
  msg: {
    amount: Uint128;
    validator: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingUndelegateMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingUndelegateMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingUndelegateMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.undelegate(msg, fee, memo, funds), options);
}
export interface CwVestingRedelegateMutation {
  client: CwVestingClient;
  msg: {
    amount: Uint128;
    dstValidator: string;
    srcValidator: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingRedelegateMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingRedelegateMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingRedelegateMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.redelegate(msg, fee, memo, funds), options);
}
export interface CwVestingDelegateMutation {
  client: CwVestingClient;
  msg: {
    amount: Uint128;
    validator: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingDelegateMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingDelegateMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingDelegateMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.delegate(msg, fee, memo, funds), options);
}
export interface CwVestingCancelMutation {
  client: CwVestingClient;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingCancelMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingCancelMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingCancelMutation>(({
    client,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.cancel(fee, memo, funds), options);
}
export interface CwVestingDistributeMutation {
  client: CwVestingClient;
  msg: {
    amount?: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingDistributeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingDistributeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingDistributeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.distribute(msg, fee, memo, funds), options);
}
export interface CwVestingReceiveMutation {
  client: CwVestingClient;
  msg: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwVestingReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwVestingReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwVestingReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}