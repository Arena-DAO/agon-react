/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.34.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Duration, PreProposeInfo, Admin, Binary, Threshold, PercentageThreshold, Decimal, Uint128, InstantiateMsg, ModuleInstantiateInfo, ExecuteMsg, CosmosMsgForEmpty, BankMsg, StakingMsg, DistributionMsg, IbcMsg, Timestamp, Uint64, WasmMsg, GovMsg, VoteOption, Vote, SingleChoiceProposeMsg, Coin, Empty, IbcTimeout, IbcTimeoutBlock, QueryMsg, MigrateMsg, Addr, Config, VoteResponse, VoteInfo, InfoResponse, ContractVersion, Expiration, Status, ProposalListResponse, ProposalResponse, SingleChoiceProposal, Votes, VoteListResponse, ProposalCreationPolicy, HooksResponse } from "./DaoMigrator.types";
import { DaoMigratorQueryClient, DaoMigratorClient } from "./DaoMigrator.client";
export const daoMigratorQueryKeys = {
  contract: ([{
    contract: "daoMigrator"
  }] as const),
  address: (contractAddress: string | undefined) => ([{ ...daoMigratorQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  config: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "config",
    args
  }] as const),
  proposal: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "proposal",
    args
  }] as const),
  listProposals: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "list_proposals",
    args
  }] as const),
  reverseProposals: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "reverse_proposals",
    args
  }] as const),
  getVote: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "get_vote",
    args
  }] as const),
  listVotes: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "list_votes",
    args
  }] as const),
  proposalCount: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "proposal_count",
    args
  }] as const),
  proposalCreationPolicy: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "proposal_creation_policy",
    args
  }] as const),
  proposalHooks: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "proposal_hooks",
    args
  }] as const),
  voteHooks: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "vote_hooks",
    args
  }] as const),
  dao: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "dao",
    args
  }] as const),
  info: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "info",
    args
  }] as const),
  nextProposalId: (contractAddress: string | undefined, args?: Record<string, unknown>) => ([{ ...daoMigratorQueryKeys.address(contractAddress)[0],
    method: "next_proposal_id",
    args
  }] as const)
};
export const daoMigratorQueries = {
  config: <TData = Config,>({
    client,
    options
  }: DaoMigratorConfigQuery<TData>): UseQueryOptions<Config, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.config(client?.contractAddress),
    queryFn: () => client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  proposal: <TData = ProposalResponse,>({
    client,
    args,
    options
  }: DaoMigratorProposalQuery<TData>): UseQueryOptions<ProposalResponse, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.proposal(client?.contractAddress, args),
    queryFn: () => client ? client.proposal({
      proposalId: args.proposalId
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  listProposals: <TData = ProposalListResponse,>({
    client,
    args,
    options
  }: DaoMigratorListProposalsQuery<TData>): UseQueryOptions<ProposalListResponse, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.listProposals(client?.contractAddress, args),
    queryFn: () => client ? client.listProposals({
      limit: args.limit,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  reverseProposals: <TData = ProposalListResponse,>({
    client,
    args,
    options
  }: DaoMigratorReverseProposalsQuery<TData>): UseQueryOptions<ProposalListResponse, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.reverseProposals(client?.contractAddress, args),
    queryFn: () => client ? client.reverseProposals({
      limit: args.limit,
      startBefore: args.startBefore
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  getVote: <TData = VoteResponse,>({
    client,
    args,
    options
  }: DaoMigratorGetVoteQuery<TData>): UseQueryOptions<VoteResponse, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.getVote(client?.contractAddress, args),
    queryFn: () => client ? client.getVote({
      proposalId: args.proposalId,
      voter: args.voter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  listVotes: <TData = VoteListResponse,>({
    client,
    args,
    options
  }: DaoMigratorListVotesQuery<TData>): UseQueryOptions<VoteListResponse, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.listVotes(client?.contractAddress, args),
    queryFn: () => client ? client.listVotes({
      limit: args.limit,
      proposalId: args.proposalId,
      startAfter: args.startAfter
    }) : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  proposalCount: <TData = Uint64,>({
    client,
    options
  }: DaoMigratorProposalCountQuery<TData>): UseQueryOptions<Uint64, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.proposalCount(client?.contractAddress),
    queryFn: () => client ? client.proposalCount() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  proposalCreationPolicy: <TData = ProposalCreationPolicy,>({
    client,
    options
  }: DaoMigratorProposalCreationPolicyQuery<TData>): UseQueryOptions<ProposalCreationPolicy, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.proposalCreationPolicy(client?.contractAddress),
    queryFn: () => client ? client.proposalCreationPolicy() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  proposalHooks: <TData = HooksResponse,>({
    client,
    options
  }: DaoMigratorProposalHooksQuery<TData>): UseQueryOptions<HooksResponse, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.proposalHooks(client?.contractAddress),
    queryFn: () => client ? client.proposalHooks() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  voteHooks: <TData = HooksResponse,>({
    client,
    options
  }: DaoMigratorVoteHooksQuery<TData>): UseQueryOptions<HooksResponse, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.voteHooks(client?.contractAddress),
    queryFn: () => client ? client.voteHooks() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  dao: <TData = Addr,>({
    client,
    options
  }: DaoMigratorDaoQuery<TData>): UseQueryOptions<Addr, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.dao(client?.contractAddress),
    queryFn: () => client ? client.dao() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  info: <TData = InfoResponse,>({
    client,
    options
  }: DaoMigratorInfoQuery<TData>): UseQueryOptions<InfoResponse, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.info(client?.contractAddress),
    queryFn: () => client ? client.info() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  nextProposalId: <TData = Uint64,>({
    client,
    options
  }: DaoMigratorNextProposalIdQuery<TData>): UseQueryOptions<Uint64, Error, TData> => ({
    queryKey: daoMigratorQueryKeys.nextProposalId(client?.contractAddress),
    queryFn: () => client ? client.nextProposalId() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface DaoMigratorReactQuery<TResponse, TData = TResponse> {
  client: DaoMigratorQueryClient | undefined;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface DaoMigratorNextProposalIdQuery<TData> extends DaoMigratorReactQuery<Uint64, TData> {}
export function useDaoMigratorNextProposalIdQuery<TData = Uint64>({
  client,
  options
}: DaoMigratorNextProposalIdQuery<TData>) {
  return useQuery<Uint64, Error, TData>(daoMigratorQueryKeys.nextProposalId(client?.contractAddress), () => client ? client.nextProposalId() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorInfoQuery<TData> extends DaoMigratorReactQuery<InfoResponse, TData> {}
export function useDaoMigratorInfoQuery<TData = InfoResponse>({
  client,
  options
}: DaoMigratorInfoQuery<TData>) {
  return useQuery<InfoResponse, Error, TData>(daoMigratorQueryKeys.info(client?.contractAddress), () => client ? client.info() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorDaoQuery<TData> extends DaoMigratorReactQuery<Addr, TData> {}
export function useDaoMigratorDaoQuery<TData = Addr>({
  client,
  options
}: DaoMigratorDaoQuery<TData>) {
  return useQuery<Addr, Error, TData>(daoMigratorQueryKeys.dao(client?.contractAddress), () => client ? client.dao() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorVoteHooksQuery<TData> extends DaoMigratorReactQuery<HooksResponse, TData> {}
export function useDaoMigratorVoteHooksQuery<TData = HooksResponse>({
  client,
  options
}: DaoMigratorVoteHooksQuery<TData>) {
  return useQuery<HooksResponse, Error, TData>(daoMigratorQueryKeys.voteHooks(client?.contractAddress), () => client ? client.voteHooks() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorProposalHooksQuery<TData> extends DaoMigratorReactQuery<HooksResponse, TData> {}
export function useDaoMigratorProposalHooksQuery<TData = HooksResponse>({
  client,
  options
}: DaoMigratorProposalHooksQuery<TData>) {
  return useQuery<HooksResponse, Error, TData>(daoMigratorQueryKeys.proposalHooks(client?.contractAddress), () => client ? client.proposalHooks() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorProposalCreationPolicyQuery<TData> extends DaoMigratorReactQuery<ProposalCreationPolicy, TData> {}
export function useDaoMigratorProposalCreationPolicyQuery<TData = ProposalCreationPolicy>({
  client,
  options
}: DaoMigratorProposalCreationPolicyQuery<TData>) {
  return useQuery<ProposalCreationPolicy, Error, TData>(daoMigratorQueryKeys.proposalCreationPolicy(client?.contractAddress), () => client ? client.proposalCreationPolicy() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorProposalCountQuery<TData> extends DaoMigratorReactQuery<Uint64, TData> {}
export function useDaoMigratorProposalCountQuery<TData = Uint64>({
  client,
  options
}: DaoMigratorProposalCountQuery<TData>) {
  return useQuery<Uint64, Error, TData>(daoMigratorQueryKeys.proposalCount(client?.contractAddress), () => client ? client.proposalCount() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorListVotesQuery<TData> extends DaoMigratorReactQuery<VoteListResponse, TData> {
  args: {
    limit?: number;
    proposalId: number;
    startAfter?: string;
  };
}
export function useDaoMigratorListVotesQuery<TData = VoteListResponse>({
  client,
  args,
  options
}: DaoMigratorListVotesQuery<TData>) {
  return useQuery<VoteListResponse, Error, TData>(daoMigratorQueryKeys.listVotes(client?.contractAddress, args), () => client ? client.listVotes({
    limit: args.limit,
    proposalId: args.proposalId,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorGetVoteQuery<TData> extends DaoMigratorReactQuery<VoteResponse, TData> {
  args: {
    proposalId: number;
    voter: string;
  };
}
export function useDaoMigratorGetVoteQuery<TData = VoteResponse>({
  client,
  args,
  options
}: DaoMigratorGetVoteQuery<TData>) {
  return useQuery<VoteResponse, Error, TData>(daoMigratorQueryKeys.getVote(client?.contractAddress, args), () => client ? client.getVote({
    proposalId: args.proposalId,
    voter: args.voter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorReverseProposalsQuery<TData> extends DaoMigratorReactQuery<ProposalListResponse, TData> {
  args: {
    limit?: number;
    startBefore?: number;
  };
}
export function useDaoMigratorReverseProposalsQuery<TData = ProposalListResponse>({
  client,
  args,
  options
}: DaoMigratorReverseProposalsQuery<TData>) {
  return useQuery<ProposalListResponse, Error, TData>(daoMigratorQueryKeys.reverseProposals(client?.contractAddress, args), () => client ? client.reverseProposals({
    limit: args.limit,
    startBefore: args.startBefore
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorListProposalsQuery<TData> extends DaoMigratorReactQuery<ProposalListResponse, TData> {
  args: {
    limit?: number;
    startAfter?: number;
  };
}
export function useDaoMigratorListProposalsQuery<TData = ProposalListResponse>({
  client,
  args,
  options
}: DaoMigratorListProposalsQuery<TData>) {
  return useQuery<ProposalListResponse, Error, TData>(daoMigratorQueryKeys.listProposals(client?.contractAddress, args), () => client ? client.listProposals({
    limit: args.limit,
    startAfter: args.startAfter
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorProposalQuery<TData> extends DaoMigratorReactQuery<ProposalResponse, TData> {
  args: {
    proposalId: number;
  };
}
export function useDaoMigratorProposalQuery<TData = ProposalResponse>({
  client,
  args,
  options
}: DaoMigratorProposalQuery<TData>) {
  return useQuery<ProposalResponse, Error, TData>(daoMigratorQueryKeys.proposal(client?.contractAddress, args), () => client ? client.proposal({
    proposalId: args.proposalId
  }) : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorConfigQuery<TData> extends DaoMigratorReactQuery<Config, TData> {}
export function useDaoMigratorConfigQuery<TData = Config>({
  client,
  options
}: DaoMigratorConfigQuery<TData>) {
  return useQuery<Config, Error, TData>(daoMigratorQueryKeys.config(client?.contractAddress), () => client ? client.config() : Promise.reject(new Error("Invalid client")), { ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  });
}
export interface DaoMigratorRemoveVoteHookMutation {
  client: DaoMigratorClient;
  msg: {
    address: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorRemoveVoteHookMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorRemoveVoteHookMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorRemoveVoteHookMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.removeVoteHook(msg, fee, memo, funds), options);
}
export interface DaoMigratorAddVoteHookMutation {
  client: DaoMigratorClient;
  msg: {
    address: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorAddVoteHookMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorAddVoteHookMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorAddVoteHookMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.addVoteHook(msg, fee, memo, funds), options);
}
export interface DaoMigratorRemoveProposalHookMutation {
  client: DaoMigratorClient;
  msg: {
    address: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorRemoveProposalHookMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorRemoveProposalHookMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorRemoveProposalHookMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.removeProposalHook(msg, fee, memo, funds), options);
}
export interface DaoMigratorAddProposalHookMutation {
  client: DaoMigratorClient;
  msg: {
    address: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorAddProposalHookMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorAddProposalHookMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorAddProposalHookMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.addProposalHook(msg, fee, memo, funds), options);
}
export interface DaoMigratorUpdatePreProposeInfoMutation {
  client: DaoMigratorClient;
  msg: {
    info: PreProposeInfo;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorUpdatePreProposeInfoMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorUpdatePreProposeInfoMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorUpdatePreProposeInfoMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updatePreProposeInfo(msg, fee, memo, funds), options);
}
export interface DaoMigratorUpdateConfigMutation {
  client: DaoMigratorClient;
  msg: {
    allowRevoting: boolean;
    closeProposalOnExecutionFailure: boolean;
    dao: string;
    maxVotingPeriod: Duration;
    minVotingPeriod?: Duration;
    onlyMembersExecute: boolean;
    threshold: Threshold;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}
export interface DaoMigratorCloseMutation {
  client: DaoMigratorClient;
  msg: {
    proposalId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorCloseMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorCloseMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorCloseMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.close(msg, fee, memo, funds), options);
}
export interface DaoMigratorExecuteMutation {
  client: DaoMigratorClient;
  msg: {
    proposalId: number;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorExecuteMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorExecuteMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorExecuteMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.execute(msg, fee, memo, funds), options);
}
export interface DaoMigratorUpdateRationaleMutation {
  client: DaoMigratorClient;
  msg: {
    proposalId: number;
    rationale?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorUpdateRationaleMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorUpdateRationaleMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorUpdateRationaleMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateRationale(msg, fee, memo, funds), options);
}
export interface DaoMigratorVoteMutation {
  client: DaoMigratorClient;
  msg: {
    proposalId: number;
    rationale?: string;
    vote: Vote;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorVoteMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorVoteMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorVoteMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.vote(msg, fee, memo, funds), options);
}
export interface DaoMigratorProposeMutation {
  client: DaoMigratorClient;
  msg: {
    description: string;
    msgs: CosmosMsgForEmpty[];
    proposer?: string;
    title: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useDaoMigratorProposeMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, DaoMigratorProposeMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, DaoMigratorProposeMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.propose(msg, fee, memo, funds), options);
}